using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Xamarin.Macios.Generator.Parsers;

namespace Xamarin.Macios.Generator;

/// <summary>
/// Source generator that writes the code needed for the export of a given selector in a class. This
/// generator does not provide the attributes but relies on those from the xamarin-macios project, this way
/// we can maintain API compatibility and remove the need of a two step compilation.
/// </summary>
[Generator]
public class BindingSourceGenerator : IIncrementalGenerator
{
    // The following attribute is a copy of the BasetypeAttribute from the xamarin-macios project, this attribute
    // is part of bgen, but instead we would want to expose itby the generator.
   private const string BaseTypeAttributeSourceCode = $@"// <auto-generated/>

namespace Foundation 
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class BindingTypeAttribute : System.Attribute
    {{
        public Type BaseType {{ get; set; }}
        public string Name {{ get; set; }}
        public Type [] Events {{ get; set; }}
        public string [] Delegates {{ get; set; }}
        public bool Singleton {{ get; set; }}

        // If set, the code will keep a reference in the EnsureXXX method for
        // delegates and will clear the reference to the object in the method
        // referenced by KeepUntilRef.   Currently uses an ArrayList, so this
        // is not really designed as a workaround for systems that create
        // too many objects, but two cases in particular that users keep
        // trampling on: UIAlertView and UIActionSheet
        public string KeepRefUntil {{ get; set; }}
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
       // Add the marker attribute to the compilation.
       context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
           "BindingTypeAttribute.g.cs",
           SourceText.From(BaseTypeAttributeSourceCode, Encoding.UTF8)));

       // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
       var provider = context.SyntaxProvider
           .CreateSyntaxProvider(
               static (s, _) => s is ClassDeclarationSyntax,
               (ctx, _) => GetClassDeclarationForSourceGen(ctx))
           .Where(t => t.BindingAttributeFound)
           .Select((t, _) => t.ClassDeclaration);

       // Generate the source code.
       context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
           ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (ClassDeclarationSyntax ClassDeclaration, bool BindingAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Binding] attribute.
            if (attributeName == "Foundation.BindingTypeAttribute")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }


    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var classData = new BindingContext(classDeclarationSyntax, semanticModel, classSymbol);
            // parse the class level attributes so that we have all the needed data to generate the class
            if (!classDeclarationSyntax.TryParseAttributes(classData, out var diagnostics))
            {
                // TODO: Add a diagnostic here to inform the user that the attribute is missing
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            var sb = new TabbedStringBuilder(new());
            // TODO: move this logic to the class data
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Drawing;");
            sb.AppendLine("using System.Diagnostics;");
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using System.Runtime.Versioning;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
            sb.AppendLine("using ObjCRuntime;");

            sb.AppendFormatLine("namespace {0}", namespaceName);

            sb.AppendLine();
            sb.AppendFormatLine("[Register(\"{0}\", true)]", className);
            sb.AppendFormatLine("public unsafe partial class {0}", className);
            using (var classBlock = sb.CreateBlock(isBlock: true))
            {
                // generate the default constructors
                DefaultConstructorEmitter.RenderDefaultConstructor(classBlock, className);
                classBlock.AppendLine();
                DefaultConstructorEmitter.RenderSkipInit(classBlock, className);
                classBlock.AppendLine();
                DefaultConstructorEmitter.RenderNativeHandlerConstructor(classBlock, className);

                // generate the methods
                var methodEmitter = new MethodEmitter(semanticModel, classBlock);
                var methods = classSymbol.GetMembers().OfType<IMethodSymbol>();
                foreach (var methodSymbol in methods)
                {
                    methodEmitter.Emit(methodSymbol);
                }

                // generate the properties
                var propertyEmitter = new PropertyEmitter(semanticModel, classBlock);
                var properties = classSymbol.GetMembers().OfType<IPropertySymbol>();
                foreach (var property in properties)
                {
                    propertyEmitter.Emit(property);
                }
            }

            var code = sb.ToString();
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}